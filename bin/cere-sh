#!/usr/bin/env python2.7

"""
Start an interactive Python REPL with some useful defaults set for
Cerebrum development.
"""

from __future__ import print_function, unicode_literals

import argparse
import datetime
import io
import logging
import os
import re

import Cerebrum.logutils
import Cerebrum.logutils.options
from Cerebrum.utils.module import load_source


# Typical globals in an environment
DEFAULT_GLOBALS = globals().copy()
logger = logging.getLogger(__name__)
PYRC = os.getenv("PYTHONSTARTUP")


def is_ipython():
    try:
        return __IPYTHON__
    except NameError:
        return False


def _ipython_repl(name, namespace):
    import IPython
    # IPython automatically sets up access to correct locals, globals
    IPython.embed(header=name)


def _python_repl(name, namespace):
    import code
    console = code.InteractiveConsole(namespace, name)
    return console.interact()


def get_repl():
    if is_ipython():
        return _ipython_repl
    else:
        return _python_repl


class AnsiAttrs(object):
    """A collection of ANSI escape codes that can be applied to text."""

    PROPS = {
        "bold": 1,
        "faint": 2,
        "underline": 4,
        "blink": 5,
        "reverse": 7,
        "concealed": 8,
        "strike": 9,
    }

    colors = ("grey", "red", "green", "yellow",
              "blue", "magenta", "cyan", "white")

    FG = dict(
        zip(colors, range(30, 38)) +
        zip((c + "_b" for c in colors), range(90, 98))
    )

    BG = dict(
        zip(("on_" + c for c in colors), range(40, 48)) +
        zip(("on_" + c + "_b" for c in colors), range(100, 108)))

    reset = "\033[0m"

    def __init__(self, attrs):
        self._props = set()
        self._bg = None
        self._fg = None
        for a in attrs:
            self.set(a)

    def set(self, attr):
        if attr in self.PROPS:
            self._props.add(attr)
        elif attr in self.FG:
            self._fg = attr
        elif attr in self.BG:
            self._bg = attr
        else:
            raise ValueError("Invalid attr %r" % (attr, ))

    def __repr__(self):
        attrs = " ".join(self.attrs)
        return "<{cls.__name__}{attrs}>".format(
            cls=type(self),
            attrs=(" " + attrs) if attrs else "")

    def __add__(self, other):
        cls = type(self)
        return cls(self.attrs + other.attrs)

    def __call__(self, text):
        return self.start + text + self.reset

    @property
    def bg(self):
        return self._bg

    @property
    def fg(self):
        return self._fg

    @property
    def props(self):
        return tuple(sorted(self._props,
                            key=lambda k: self.PROPS[k]))

    @property
    def attrs(self):
        self.props + tuple(c for c in (self.fg, self.bg) if c)

    @property
    def values(self):
        values = {self.PROPS[p] for p in self._props}
        values.update(c for c in (self.BG.get(self._bg), self.FG.get(self._fg))
                      if c is not None)
        return tuple(sorted(values))

    @property
    def start(self):
        return "\033[" + ";".join(str(a) for a in self.values) + "m"


def colorize(text, *attrs):
    ansi = AnsiAttrs(attrs)
    return ansi(text)


def print_color_matrix():
    fg_pad = max(len(c) for c in AnsiAttrs.FG)
    bg_pad = max(len(c) for c in AnsiAttrs.BG)
    # bg headers
    print(" " * (len("* ") + fg_pad), end=" ")
    for fg, bg in zip(sorted(AnsiAttrs.FG), sorted(AnsiAttrs.BG)):
        print(bg.ljust(bg_pad), end=" ")
    print("")

    # bg
    for fg in sorted(AnsiAttrs.FG):
        # normal
        print(colorize("*", fg), fg.ljust(fg_pad), end=" ")
        for bg in sorted(AnsiAttrs.BG):
            print(colorize(bg.ljust(bg_pad), fg, bg), end=" ")
        print("")


def print_text_effects():
    fg_pad = max(len(c) for c in AnsiAttrs.FG)
    # fg colors
    for fg in sorted(AnsiAttrs.FG):
        print(fg.ljust(fg_pad), end=" ")
        print(colorize("bold", fg, "bold"), end=" ")
        print(colorize("normal", fg), end=" ")
        print(colorize("faint", fg, "faint"), end=" ")
        print("", end=" ")
        for effect in ["underline", "blink", "reverse", "concealed", "strike"]:
            print(colorize(effect, fg, effect), end=" ")
        print("")
    print("")


def _log_time(fn):
    def wrapper(*args):
        start = datetime.datetime.utcnow()
        try:
            return fn(*args)
        finally:
            end = datetime.datetime.utcnow()
            logger.debug("%s%r done in %.02fs",
                         fn.__name__, args, (end - start).total_seconds())
    return wrapper


class Namespace(object):
    """ A dict namespace for evaluating code. """

    def __init__(self, d=None):
        if d is None:
            d = {}
        self.data = d

    @_log_time
    def execfile(self, filename):
        glob = {"__name__": "__main__"}
        execfile(filename, glob)
        for name in glob:
            if name in DEFAULT_GLOBALS:
                continue
            self.data[name] = glob[name]
        return glob

    @_log_time
    def execline(self, runtype, line):
        glob = {}
        if runtype == "stmt":
            exec(line, glob, self.data)
        elif runtype == "expr":
            eval(line, glob, self.data)
        elif runtype == "noop":
            pass
        else:
            raise ValueError("Invalid runtype %r" % (runtype, ))
        return glob

    def __iter__(self):
        return iter(self.data)

    def __len__(self):
        return len(self.data)

    def __getitem__(self, item):
        return self.data[item]

    def __setitem__(self, item, value):
        self.data[item] = value


class Formatter(object):
    """ Format output for a buffer. """

    def __init__(self, use_colors=True):
        self.use_colors = use_colors

    def color(self, text, *attrs):
        if self.use_colors and attrs:
            return colorize(text, *attrs)
        else:
            return text

    def header(self, *s):
        return self.color("[ " + " ".join(s) + " ]", "blue")

    def line(self, *s):
        return " ".join(str(i) for i in s)

    def _key(self, k, size=0):
        pad = max(0, size - len(k))
        return self.color(k, "white") + ": " + (" " * pad)

    def _value(self, v):
        if isinstance(v, basestring):
            return self.color(repr(v), "yellow")
        if isinstance(v, (int, long, bool)):
            return self.color(repr(v), "blue")
        else:
            return self.color(repr(v), "magenta")

    def kv(self, items):
        items = tuple(items)
        klen = max(len(k) for k, _ in items)
        for k, v in items:
            yield self._key(k, size=klen), self._value(v)

    def execline(self, is_error, *s):
        line = " ".join(s)
        line, sep, comment = line.partition("#")
        line = line.strip()
        comment = comment.strip()
        if line and comment:
            comment = "  # " + comment
        elif comment:
            comment = "# " + comment

        return "".join((
            self.color(line.rstrip(),
                       "red" if is_error else "green"),
            self.color(comment, "white"),
        ))


class Buffer(object):
    """ Output a group of related lines. """

    def __init__(self, formatter, header=None, indent=2):
        self._indent = indent
        self._buffer = io.StringIO()
        self.fmt = formatter

        self._out(self.fmt.header(header))
        self.has_output = False

    def _out(self, *s):
        print(" " * self._indent,
              "".join(s),
              sep="",
              file=self._buffer)
        self.has_output = True

    def line(self, line):
        self._out(self.fmt.line(line))

    def exec_ok(self, *s):
        self._out(self.fmt.execline(False, *s))

    def exec_err(self, *s):
        self._out(self.fmt.execline(True, *s))

    def dict(self, items):
        if isinstance(items, dict):
            items = items.items()
        for k, v in self.fmt.kv(items):
            self._out(k, v)

    def get_output(self):
        return self._buffer.getvalue()


def load_module(name, filename=None):
    """ Load a given module (optionally from a given file). """
    if filename:
        module = load_source(name, filename)
    else:
        module = __import__(name)
    return module


def cereconf_type(filename):
    """ Normalize and validate cereconf module file name. """
    if filename is None:
        return
    filename = os.path.expanduser(filename)
    if not os.path.isfile(filename):
        raise argparse.ArgumentTypeError(
            "Unable to read {}".format(filename))
    return filename


def read_opt_file_type(filename):
    """ Normalize and check generic python file. """
    filename = os.path.expanduser(filename)
    if not os.path.isfile(filename):
        raise argparse.ArgumentTypeError(
            "Unable to read {}".format(filename))
    return filename


parser = argparse.ArgumentParser()
use_colors = parser.add_mutually_exclusive_group()
use_colors.add_argument(
    "--color",
    dest="use_colors",
    action="store_true",
)
use_colors.add_argument(
    "--no-color",
    dest="use_colors",
    action="store_false",
)
use_colors.set_defaults(use_colors=True)
parser.add_argument(
    "-c", "--cereconf",
    type=cereconf_type,
    help="Path to a cereconf module (default: %(default)s)"
)
parser.add_argument(
    "files",
    nargs="*",
    type=read_opt_file_type
)
Cerebrum.logutils.options.install_subparser(parser)


def main(inargs=None):
    progname = re.sub(r"\.py$", "", parser.prog).replace(".", "-")
    args = parser.parse_args(inargs)

    # Configure output
    formatter = Formatter(use_colors=args.use_colors)
    section_scripts = Buffer(formatter, header="scripts")
    section_setup = Buffer(formatter, header="setup")
    section_info = Buffer(formatter, header="info")

    namespace = Namespace({
        "__name__": "__main__",
        "logging": logging,
        "args": args,
    })

    # load cereconf
    namespace["cereconf"] = cereconf = load_module("cereconf", args.cereconf)
    section_setup.exec_ok("import cereconf")

    # configure logging
    default_preset = "console"
    Cerebrum.logutils.autoconf(default_preset, args)

    # run pyrc, any scripts from args
    files = list(args.files)
    if PYRC is not None and os.path.isfile(PYRC):
        logger.debug("Using PYTHONSTARTUP=%r", PYRC)
        files.append(PYRC)
    for f in files:
        logger.info("Running %r", f)
        line = "execfile({})".format(repr(f))
        try:
            namespace.execfile(f)
            section_scripts.exec_ok(line)
        except Exception as e:
            logger.error("Unable to run filename=%r: %s", f, e)
            section_scripts.exec_err(line)

    run = tuple((
        ("stmt", "from Cerebrum.Utils import Factory"),
        ("stmt", "from Cerebrum import Errors"),
        ("stmt", "Account = Factory.get("Account")"),
        ("stmt", "Constants = Factory.get("Constants")"),
        ("stmt", "CLConstants = Factory.get("CLConstants")"),
        ("stmt", "Database = Factory.get("Database")"),
        ("stmt", "Entity = Factory.get("Entity")"),
        ("stmt", "Group = Factory.get("Group")"),
        ("stmt", "Person = Factory.get("Person")"),
        ("stmt", "db = Database(client_encoding="utf-8")"),
        ("stmt", "co = Constants(db)"),
        ("stmt", "cl = CLConstants(db)"),
        ("stmt", "en = Entity(db)"),
        ("stmt", "ac = Account(db)"),
        ("stmt", "gr = Group(db)"),
        ("stmt", "pe = Person(db)"),
        ("stmt", "di = Factory.get("Disk")(db)"),
        ("stmt", "ou = Factory.get("OU")(db)"),
        ("stmt", "pu = Factory.get("PosixUser")(db)"),
        ("stmt", "pg = Factory.get("PosixGroup")(db)"),
        ("stmt", "boot = Account(db)"),
        ("expr", "boot.find_by_name(cereconf.INITIAL_ACCOUNTNAME)"),
        ("expr", "db.cl_init(change_program={})".format(repr(progname))),
        ("stmt", "logger = logging.getLogger({})".format(repr(progname))),
    ))
    for runtype, line in run:
        try:
            namespace.execline(runtype, line)
            section_setup.exec_ok(line)
        except Exception as e:
            logger.error("Unable to run runtype=%r (line=%r): %s",
                         runtype, line, e)
            section_setup.exec_err(line)

    section_info.dict((
        ("pid", os.getpid()),
        ("pwd", os.getcwd()),
        ("cereconf", cereconf.__file__),
        ("database", getattr(cereconf, "CEREBRUM_DATABASE_NAME")),
        ("logging", ((args.logger_name or default_preset),
                     logging.getLevelName(logging.getLogger().level))),
    ))

    if section_scripts.has_output:
        print(section_scripts.get_output(), sep="")
    if section_setup.has_output:
        print(section_setup.get_output(), sep="")
    if section_info.has_output:
        print(section_info.get_output(), sep="")

    # start interactive session
    repl = get_repl()
    g = globals()
    g.update(namespace.data)
    repl(progname, g)


if __name__ == "__main__":
    main()

